{
    "collab_server" : "",
    "contents" : "\"Survr\" <-\nfunction (id,time,event) \n{\n \n    if(length(unique(id))!=length(event[event==0]))\n      {\n        stop(\"Data doesn't match. Every subject must have a censored time\")\n      }\n\n    if(length(unique(event))>2 | max(event)!=1 | min(event)!=0)\n      {\n        stop(\"event must be 0-1\")\n      }\n\n    ans<-cbind(id,time,event)\n\n    oldClass(ans) <- \"Survr\"\n    invisible(ans)\n\n}\n\n\"is.Survr\" <-\nfunction(x)\ninherits(x, \"Survr\")\n\n\n\"psh.fit\" <-\nfunction (x, tvals) \n{\n    if (!is.Survr(x)) {\n        stop(\"\\n x must be a Survr object\")\n    }\n    n <- length(unique(x[, 1]))\n    failed <- c(x[, 2][x[, 3] == 1])\n    censored <- c(x[, 2][x[, 3] == 0])\n    m <- table(x[, 1]) - 1\n    sfailed <- sort(failed)\n    nfailed <- length(failed)\n    summ <- .Fortran(\"DistinctFailed\", as.integer(n), as.integer(m), \n        as.double(failed), as.double(sfailed), as.integer(nfailed), \n        as.double(censored), as.integer(0), as.double(rep(0, \n            nfailed)), as.integer(rep(0, nfailed)), as.integer(rep(0, \n            n * nfailed)), PACKAGE = \"survrec\")\n    numdistinct <- summ[[7]]\n    distinct <- summ[[8]][1:numdistinct]\n    numdeaths <- summ[[9]][1:numdistinct]\n    vAtRisk <- summ[[10]][1:(n * numdistinct)]\n    AtRisk <- matrix(vAtRisk, nrow = n, ncol = numdistinct)\n    survfuncPSHple <- vector(\"numeric\", numdistinct)\n    AtRiskTotals <- t(AtRisk) %*% c(rep(1, n))\n    survfuncPSHple.i <- 1 - (numdeaths/AtRiskTotals)\n    survfuncPSHple <- cumprod(survfuncPSHple.i)\n\n    se.NA<-cumsum(numdeaths/(AtRiskTotals)^2)\n    se.PLE<-sqrt(se.NA*survfuncPSHple^2) \n\n    if (!missing(tvals)) {\n        tvalslen <- length(tvals)\n        tvals.o <- sort(tvals)\n        PSHpleAttvals <- surv.search(tvals.o, distinct, survfuncPSHple)\n    }\n    else {\n        tvals <- NA\n        PSHpleAttvals <- NA\n    }\n    ans <- list(n = n, m = m, failed = failed, censored = censored, \n        time = distinct, n.event = numdeaths, AtRisk = AtRisk, \n        survfunc = survfuncPSHple, std.error=se.PLE,tvals = tvals, \n        PSHpleAttvals = PSHpleAttvals)\n    oldClass(ans) <- \"survfitr\"\n    ans\n}\n\n\n\n\n\"wc.fit\" <-\nfunction (x, tvals) \n{\n    if (!is.Survr(x)) {\n        stop(\"\\n x must be a Survr object\")\n    }\n    n <- length(unique(x[, 1]))\n    failed<-c(x[,2][x[,3]==1]) \n    gap <- c(x[, 2])\n    cen.gap <- c(x[, 2][x[, 3] == 0])\n    event <- c(x[,3])\n    tot <- length(gap) \n    distinct <- sort(unique(c(x[, 2][x[, 3] == 1])))    \n    ndistinct <- length(distinct)\n    uid <- unique(x[, 1])\n    m <- as.integer(table(x[, 1]))\n    mMax<-max(m)\n    wt<-rep(1,n)\n        \n    summ <- .Fortran(\"wc2\",\n\t\t  as.integer(n),\n\t\t  as.double(matrix(0,nrow=n,ncol=mMax)),\n\t\t  as.double(wt),\n\t\t  as.double(m),\n\t\t  as.integer(mMax),\n\t\t  as.integer(m),\n\t\t  as.double(matrix(0,nrow=n,ncol=mMax)),\n\t\t  as.double(m - 1),\n\t\t  as.integer(ndistinct),\n\t\t  as.double(distinct),\n\t\t  as.integer(tot),\n\t\t  as.double(gap),\t\t  \n                  as.double(event),\t\t  \n                  r=as.double(rep(0,ndistinct)),\n\t\t  d=as.double(rep(0,ndistinct)),\n\t\t  surv=as.double(rep(0,ndistinct)),\n\t\t  var=as.double(rep(0,ndistinct)),  PACKAGE = \"survrec\")\n \n    survfuncWCple <- summ$surv\n\n    if (!missing(tvals)) {\n        tvalslen <- length(tvals)\n        tvals.o <- sort(tvals)\n        WCpleAttvals <- surv.search(tvals.o, distinct, survfuncWCple)\n    }\n    else {\n        tvals <- NA\n        WCpleAttvals <- NA\n    }\n    ans <- list(n = n, m = m, failed = failed, censored = cen.gap, \n        time = distinct, n.event = summ$d, AtRisk = summ$r, \n        survfunc = survfuncWCple, std.error=summ$var, tvals = tvals, \n        WCpleAttvals = WCpleAttvals)\n    oldClass(ans) <- \"survfitr\"\n    ans\n}\n\n\n\"mlefrailty.fit\"<-\nfunction (x, tvals, lambda = NULL, alpha = NULL, alpha.min, alpha.max, \n    tol = 1e-07, maxiter = 500, alpha.console=TRUE) \n{\n    if (!is.Survr(x)) {\n        stop(\"\\n x must be a Survr object\")\n    }\n    n <- length(unique(x[, 1]))\n    failed <- c(x[, 2][x[, 3] == 1])\n    censored <- c(x[, 2][x[, 3] == 0])\n    m <- table(x[, 1])-1\n    sfailed <- sort(failed)\n    nfailed <- length(failed)\n    summ <- .Fortran(\"DistinctFailed\", as.integer(n), as.integer(m), \n        as.double(failed), as.double(sfailed), as.integer(nfailed), \n        as.double(censored), as.integer(0), as.double(rep(0, \n            nfailed)), as.integer(rep(0, nfailed)), as.integer(rep(0, \n            n * nfailed)),PACKAGE=\"survrec\")\n    numdistinct <- summ[[7]]\n    distinct <- summ[[8]][1:numdistinct]\n    numdeaths <- summ[[9]][1:numdistinct]\n    vAtRisk <- summ[[10]][1:(n * numdistinct)]\n    AtRisk <- matrix(vAtRisk, nrow = n, ncol = numdistinct)\n    if (is.null(lambda[1])) {\n        lambda <- as.vector(numdeaths/apply(AtRisk,2,sum))\n    }\n    if (is.null(alpha)) {\n \n        if(alpha.console)\n              cat(\"\\nNeeds to Determine a Seed Value for Alpha\")\n        if (missing(alpha.min)) {\n            alpha.min <- 0.5\n        }\n        if (missing(alpha.max)) {\n            alpha.max <- max(distinct)\n        }\n        tol.max <- (alpha.max - alpha.min)/50\n        Seed <- .Fortran(\"searchforseed\", as.integer(n), as.integer(m), \n            as.integer(numdistinct), as.double(distinct), as.integer(numdeaths), \n            as.integer(AtRisk), as.double(lambda), as.double(alpha.min), \n            as.double(alpha.max), as.double(tol.max), as.double(0), \n            as.integer(0),PACKAGE=\"survrec\")\n        alpha <- Seed[[11]]\n        if(alpha.console)\n               cat(\"\\n Seed Alpha: \", alpha)\n        IER <- Seed[[12]]\n        if (IER != 0 && alpha.console) {\n            warning(\"Problem with the seed value for alpha\")\n            if (IER == 129) {\n                warning(\"bL is greater than or equal to bR. Minimum as bL\")\n            }\n            if (IER == 130) {\n                warning(\"tol is greater than the interval bL to bR\")\n            }\n            if (IER == 131) {\n                warning(\"the function is not unimodal. Check your results\")\n            }\n        }\n    }\n    alphadel <- alpha/4\n    alphaseeds <- c(alpha, alpha - alphadel, alpha - 2 * alphadel, \n        alpha - 3 * alphadel, alpha + alphadel, alpha + 2 * alphadel, \n        alpha + 3 * alphadel)\n    status <- 0\n    ind <- 0\n    while ((status == 0) && (ind < 7)) {\n        ind <- ind + 1\n        alpha <- alphaseeds[ind]\n        Estimates <- .Fortran(\"emalgo\", as.integer(n), as.integer(m), \n            as.integer(numdistinct), as.double(distinct), as.integer(numdeaths), \n            as.integer(AtRisk), as.double(lambda), as.double(alpha), \n            as.double(tol), as.integer(maxiter), as.integer(status),PACKAGE=\"survrec\")\n        status <- Estimates[[11]]\n    }\n    alpha <- Estimates[[8]]\n    if (alpha.console)\n      { \n        cat(\"\\n \")\n        cat(\"\\n Alpha estimate=\", alpha)\n        cat(\"\\n \")\n      }\n    lambda <- Estimates[[7]]\n    if (!missing(tvals)) \n        tvalslen <- length(tvals)\n    if (!(status == 1)) {\n        cat(\"\\n\\n WARNING: No estimates will be provided!\")\n        cat(\"\\n Value of (status,alpha) from iteration is \", \n            c(status, alpha), \"\\n\\n\")\n        alpha <- NA\n        survfuncMLE <- c(rep(NA, numdistinct))\n        if (!missing(tvals)) \n            MLEAttvals <- c(rep(NA, tvalslen))\n        else {\n            tvals <- NA\n            MLEAttvals <- NA\n        }\n    }\n    else {\n        if (alpha >= 1e+05) \n            alpha <- 1e+05\n        temp <- .Fortran(\"mlevalue\", as.integer(numdistinct), \n            as.double(alpha), as.double(lambda), as.double(rep(0, \n                numdistinct)),PACKAGE=\"survrec\")\n        survfuncMLE <- temp[[4]]\n        if (!missing(tvals)) {\n            tvalslen <- length(tvals)\n            tvals.o <- sort(tvals)\n            MLEAttvals <- surv.search(tvals.o, distinct, survfuncMLE)\n        }\n        else {\n            tvals <- NA\n            MLEAttvals <- NA\n        }\n    }\n    ans <- list(n = n, m = m, failed = failed, censored = censored, \n        time = distinct, n.event = numdeaths, AtRisk = AtRisk, \n        status = status, alpha = alpha, lambda=lambda, survfunc = survfuncMLE, \n        tvals = tvals, MLEAttvals = MLEAttvals)\n    oldClass(ans) <- \"survfitr\"\n    ans\n}\n\n\n\n\n\"surv.search\" <-\nfunction (tvals,time,surv)\n{\n  time.c<-c(0,time)\n  surv.c<-c(1,surv)\n  mm<-outer(tvals,time.c,\">=\")\n  pos<-apply(mm,1,sum)\n  return(surv.c[pos])\n}\n\n\n\"q.search\" <-\nfunction (f, q=0.5) \n{\n     tt <- c(0, f$time)\n     ss <- c(1, f$surv)\n     if(ss[length(ss)] > q)\n        stop(paste(\"\\noverall survival estimate does not fall below \",q))\n     ans<-min(tt[ss <= q])\n     return(ans)\n}\n\n\n\n\"survfitr\" <-\nfunction (formula, data, type=\"MLEfrailty\",...) \n{\n   method <- charmatch(type, c(\"pena-strawderman-hollander\", \n             \"wang-chang\", \"MLEfrailty\"), nomatch= 0)\n   if(method == 0)\n\t{\n\t  stop(\"estimator must be pena-strawderman-hollander wang-chang or MLEfrailty\")\n        }\n\n    call <- match.call()\n    if ((mode(call[[2]]) == \"call\" && call[[2]][[1]] == as.name(\"Survr\")) || \n        inherits(formula, \"Survr\")) {\n\n    stop(\"formula.default(object): invalid formula\")\n     }\n\n    m <- match.call(expand.dots = FALSE)\n    m$type<- m$... <- NULL\n    Terms <- terms(formula, \"strata\")\n    ord <- attr(Terms, \"order\")\n    if (length(ord) & any(ord != 1)) \n        stop(\"Interaction terms are not valid for this function\")\n    m$formula <- Terms\n    m[[1]] <- as.name(\"model.frame\")\n    m <- eval(m, sys.parent())\n    n <- nrow(m)\n    Y <- model.extract(m, \"response\")\n    if (!is.Survr(Y)) \n        stop(\"Response must be a survival recurrent object\")\n    ll <- attr(Terms, \"term.labels\")\n    \n    if(method==1) FUN<-psh.fit\n    if(method==2) FUN<-wc.fit\n    if(method==3) FUN<-mlefrailty.fit\n\n    if (ncol(m)>1) {\n        group <- m[ll][, 1]  \n        k <- levels(group)\n        ans <- NULL\n        for (i in 1:length(k)) {\n            temp <- Y[group == k[i], ]\n            temp1 <- Survr(temp[, 1], temp[, 2], temp[, 3])\n            ans[[i]] <- FUN(temp1,...)\n        }\n        names(ans) <- k\n        oldClass(ans) <- \"survfitr\"\n        attr(ans, \"strata\") <- length(k)\n        attr(ans, \"group\") <- ll\n    }\n    else {\n        temp<-Survr(Y[,1],Y[,2],Y[,3]) \n        ans <- FUN(temp,...)\n    }\n    ans\n}\n\n\"survdiffr\" <-\nfunction (formula, data, q, B=500, boot.F=\"WC\",boot.G=\"none\",...) \n{\n   \n  stop(\"This function is not working anymore. Please contact the maintiner\")\n  \n   method.F <- charmatch(boot.F, c(\"PSH\",\"WC\", \"semiparametric\"), nomatch= 0)\n   if(method.F == 0)\n\t{\n\t  stop(\"bootstrap froom F must be PSH WC or semiparametric\")\n        }\n   if(method.F == 3)\n        {\n          stop(\"Problems with Fortran code. Please contact with mantainer\") \n        }\n\n   method.G <- charmatch(boot.G, c(\"none\",\"empirical\"), nomatch= 0)\n   if(method.G == 0)\n\t{\n\t  stop(\"bootstrap from G must be none or empirical\")\n        }\n\n   if (method.F==1) {\n        type.boot <- 2 + method.G - 1\n        type <- \"p\"\n     }  \n   if (method.F==2) {\n        type.boot <- 4 + method.G - 1 \n        type <- \"w\"\n     }  \n   if (method.F==3) {\n        type.boot <- 6 + method.G - 1\n        type <- \"M\"\n     }  \n\n\n    call <- match.call()\n    if ((mode(call[[2]]) == \"call\" && call[[2]][[1]] == as.name(\"Survr\")) || \n        inherits(formula, \"Survr\")) {\n\n    stop(\"formula.default(object): invalid formula\")\n     }\n\n    m <- match.call(expand.dots = FALSE)\n    m$q<-  m$B<-  m$boot.F<- m$... <- NULL\n    Terms <- terms(formula, \"strata\")\n    ord <- attr(Terms, \"order\")\n    if (length(ord) & any(ord != 1)) \n        stop(\"Interaction terms are not valid for this function\")\n    m$formula <- Terms\n    m[[1]] <- as.name(\"model.frame\")\n    m <- eval(m, sys.parent())\n    n <- nrow(m)\n    Y <- model.extract(m, \"response\")\n    if (!is.Survr(Y)) \n        stop(\"Response must be a survival recurrent object\")\n    ll <- attr(Terms, \"term.labels\")\n    group <- m[ll][, 1]\n\n\n    if (!is.null(group)) {\n        k <- levels(group)\n        ans <-list(NULL)\n        for (i in 1:length(k)) {\n            temp <- Y[group == k[i], ]\n            Sr <- Survr(temp[, 1], temp[, 2], temp[, 3])\n            n <- length(unique(Sr[,1]))\n            failed<-c(Sr[,2][Sr[,3]==1])\n            censored<-c(Sr[,2][Sr[,3]==0])\n            m <- table(Sr[, 1])-1\n\n           sfailed<-sort(failed)\n           nfailed<-length(failed)\n\n           tau<-rep(NA,n)\n           id.unique<-unique(Sr[,1])\n           for (j in 1:n)\n            {\n             tau[j]<-sum(Sr[,2][Sr[,1]==id.unique[j]])\n            }\n           summ <- .Fortran(\"bootmedian\",\n                         as.integer(n),\n                         as.integer(m),\n                         as.double(failed),\n                         as.double(sfailed),\n                         as.integer(nfailed),\n                         as.double(censored),\n                         as.double(tau),\n                         as.integer(B),\n                         as.integer(type.boot), \n                         as.double(q),\n                         as.double(rep(0,B)), PACKAGE = \"survrec\")\n\n           ans[[i]]<-list(NULL)\n           ans[[i]]$t0<-q.search(survfitr(Sr~1,type=type),q=q)\n           ans[[i]]$t<-cbind(summ[[11]])\n           ans[[i]]$R<-B\n           ans[[i]]$data<-unclass(Sr)\n           ans[[i]]$seed<-.Random.seed\n           ans[[i]]$statistic<-NULL\n           ans[[i]]$sim<-c(\"ordinary\")\n           ans[[i]]$call<-call\n           ans[[i]]$stype<-c(\"i\")\n           ans[[i]]$strata<-rep(1,nrow(Sr))\n           ans[[i]]$weights<-rep(1/nrow(Sr),nrow(Sr))\n           oldClass(ans[[i]])<-\"boot\"\n         }\n         names(ans)<-k\n    }\n    else {\n            Sr<-Survr(Y[,1],Y[,2],Y[,3]) \n            n <- length(unique(Sr[,1]))\n            failed<-c(Sr[,2][Sr[,3]==1])\n            censored<-c(Sr[,2][Sr[,3]==0])\n            m <- table(Sr[, 1])-1\n\n           sfailed<-sort(failed)\n           nfailed<-length(failed)\n\n           tau<-rep(NA,n)\n           id.unique<-unique(Sr[,1])\n           for (i in 1:n)\n            {\n             tau[i]<-sum(Sr[,2][Sr[,1]==id.unique[i]])\n            }\n           summ <- .Fortran(\"bootmedian\",\n                         as.integer(n),\n                         as.integer(m),\n                         as.double(failed),\n                         as.double(sfailed),\n                         as.integer(nfailed),\n                         as.double(censored),\n                         as.double(tau),\n                         as.integer(B),\n                         as.integer(type.boot), \n                         as.double(q),\n                         as.double(rep(0,B)), PACKAGE = \"survrec\")\n                     \n           ans<-NULL\n           ans$t0<-q.search(survfitr(Sr~1,type=type),q=q)\n           ans$t<-cbind(summ[[11]])\n           ans$R<-B\n           ans$data<-unclass(Sr)\n           ans$seed<-.Random.seed\n           ans$statistic<-NULL\n           ans$sim<-c(\"ordinary\")\n           ans$call<-call\n           ans$stype<-c(\"i\")\n           ans$strata<-rep(1,nrow(Sr))\n           ans$weights<-rep(1/nrow(Sr),nrow(Sr))\n           oldClass(ans)<-\"boot\"\n    \n    }\n\nans\n\n}\n\n\n\n\"plot.survfitr\" <-\nfunction (x, conf.int=TRUE, prob = FALSE, ...) \n{\n    dostep <- function(x, y) {\n        if (is.na(x[1] + y[1])) {\n            x <- x[-1]\n            y <- y[-1]\n        }\n        n <- length(x)\n        if (n > 2) {\n            dupy <- c(TRUE, diff(y[-n]) != 0, TRUE)\n            n2 <- sum(dupy)\n            xrep <- rep(x[dupy], c(1, rep(2, n2 - 1)))\n            yrep <- rep(y[dupy], c(rep(2, n2 - 1), 1))\n            list(x = xrep, y = yrep)\n        }\n        else if (n == 1) \n            list(x = x, y = y)\n        else list(x = x[c(1, 2, 2)], y = y[c(1, 1, 2)])\n    }\n    y.lab <- ifelse(prob, \"Probability Estimates\", \"Survivor Probability Estimates\")\n    if (!prob) {\n        if (!is.null(attr(x, \"strata\"))) {\n            plot(dostep(x[[1]]$time, x[[1]]$surv), type = \"n\", \n                xlab = \"Time\", ylab = y.lab, ...)\n            for (i in 1:attr(x, \"strata\")) {\n                y <- x[[i]]$surv\n                if((is.null(x[[i]]$std.error)) || (!conf.int))\n                   e<-1\n                else \n                   e <- x[[i]]$std.error\n                lines(dostep(x[[i]]$time, y), col = i)\n                lines(dostep(x[[i]]$time, y+qnorm(0.975)*e), col=i, lty=2)\n                lines(dostep(x[[i]]$time, y-qnorm(0.975)*e), col=i, lty=2)\n            }\n        }\n        else {\n            y <- x$surv\n            if((is.null(x$std.error)) || (!conf.int))\n              e<-1\n            else \n              e <- x$std.error\n            plot(dostep(x$time, y), type = \"l\", ylim = c(0, max(y)), \n                xlab = \"Time\", ylab = y.lab)\n            lines(dostep(x$time, y+qnorm(0.975)*e),lty=2)\n            lines(dostep(x$time, y-qnorm(0.975)*e),lty=2)\n\n        }\n    }\n    else {\n        if (!is.null(attr(x, \"strata\"))) {\n            plot(dostep(x[[1]]$time, 1 - x[[1]]$surv), type = \"n\", \n                xlab = \"Time\", ylab = y.lab, ...)\n            for (i in 1:attr(x, \"strata\")) {\n                y <- x[[i]]$surv\n                if((is.null(x[[i]]$std.error)) || (!conf.int))\n                   e<-1\n                else \n                   e <- x[[i]]$std.error\n                lines(dostep(x[[i]]$time, 1-y), col = i)\n                lines(dostep(x[[i]]$time, 1-y+qnorm(0.975)*e), col=i, lty=2)\n                lines(dostep(x[[i]]$time, 1-y-qnorm(0.975)*e), col=i, lty=2)\n\n            }\n        }\n        else {\n            y <- x$surv\n            if((is.null(x$std.error)) || (!conf.int))\n                e<-1\n            else \n                e <- x$std.error\n            plot(dostep(x$time, 1 - y), type = \"l\", ylim = c(0, \n                max(y)), xlab = \"Time\", ylab = y.lab)\n            lines(dostep(x$time, 1 - y+qnorm(0.975)*e),lty=2)\n            lines(dostep(x$time, 1 - y-qnorm(0.975)*e),lty=2)\n        }\n    }\n    return(invisible())\n}\n\n\n\n\"lines.survfitr\"<-\nfunction (x, prob=FALSE, ...) \n{\n    dostep <- function(x, y) {\n        if (is.na(x[1] + y[1])) {\n            x <- x[-1]\n            y <- y[-1]\n        }\n        n <- length(x)\n        if (n > 2) {\n            dupy <- c(TRUE, diff(y[-n]) != 0, TRUE)\n            n2 <- sum(dupy)\n            xrep <- rep(x[dupy], c(1, rep(2, n2 - 1)))\n            yrep <- rep(y[dupy], c(rep(2, n2 - 1), 1))\n            list(x = xrep, y = yrep)\n        }\n        else if (n == 1) \n            list(x = x, y = y)\n        else list(x = x[c(1, 2, 2)], y = y[c(1, 1, 2)])\n    }\nif(!prob)\n    lines(dostep(x$time, x$survfunc), ...)\nelse\n    lines(dostep(x$time, 1-x$survfunc), ...)\n    return(invisible())\n}\n\n\n\n\"print.survfitr\" <-\nfunction (x,scale=1,digits = max(options()$digits - 4, 3), ...) \n{\n\n  savedig <- options(digits = digits)\n  on.exit(options(savedig))\n  plab<-c(\"n\",\"events\",\"mean\",\"se(mean)\",\"median\",\"recurrences: min\",\"max\",\"median\")\n\n  pfun <- function(x)\n    #compute the mean, se(mean) and median survival\n\t{\n          minmin <- function(y, xx)\n            {\n\t     if(any(!is.na(y) & y == 0.5)) {\n\t\tif(any(!is.na(y) & y < 0.5))\n\t\t  0.5 * (min(xx[!is.na(y) & y == 0.5]) + min(xx[!is.na(y) & y < 0.5]))\n\t\telse 0.5 * (min(xx[!is.na(y) & y == 0.5]) + max(xx[!is.na(y) & y == 0.5]))\n\t\t\t}\n\t\t\telse min(xx[!is.na(y) & y <= 0.5])\n\t\t}\n\n                stime<-x$time/scale\n           \t    n <- length(stime)\n          \t    if (is.matrix(x$AtRisk))\n                      {n.risk<-apply(x$AtRisk,2,sum)}\n                    else\n                      {n.risk<-x$AtRisk}\n                hh <- c(x$n.event[ - n]/(n.risk[ - n] * (n.risk[ - n] - x$n.event[ - n])), 0)\n\t       \n                med <- minmin(x$survfunc, x$time)\n               \n\n                dif.time <- c(diff(c(0, stime)), 0)\n                mean <- dif.time * c(1, x$survfunc)\n\n                varmean <- sum(rev(cumsum(rev(mean))^2)[-1] * hh)                 \n\n                ans<-c(x$n, sum(x$m), sum(mean), sqrt(varmean), med, min(x$m),\n                       max(x$m), median(x$m))\n                ans\n}\n\n\nif(is.null(attr(x,\"strata\")))\n  {\n   # no strata \n    x1<-rbind(pfun(x))\n    cat(\"Survival for recurrent event data\")\n    cat(\"\\n\")\n    dimnames(x1)<-list(\" \",plab)\n    print(x1)\n    cat(\"\\n\")\n  }\n\nelse\n  {\n      cat(\"Survival for recurrent event data. Group=\" ,attr(x,\"group\"))\n      cat(\"\\n\")  \n      x1<-NULL\n      for (i in 1:attr(x,\"strata\"))\n        {\n         temp<-pfun(x[[i]])\n         x1<-rbind(x1,temp)\n        }\n      temp<-names(x)\n      dimnames(x1)<-list(temp,plab)\n      print(x1)\n      cat(\"\\n\")\n   }\n\ninvisible(x)\n\n}\n\n\n\"summary.survfitr\" <-\nfunction (object, ...) \n{\n    x <- object\n    if (!inherits(x, \"survfitr\")) \n        stop(\"Invalid data\")\n    if (is.null(x[[1]]$std.error)) {\n        plab <- c(\"time\", \"n.event\", \"n.risk\", \"surv\")\n        if (!is.null(attr(x, \"strata\"))) {\n            ans <- list(NA)\n            for (i in 1:attr(x, \"strata\")) {\n                if (is.matrix(x[[i]]$AtRisk))\n                    {n.risk<-apply(x[[i]]$AtRisk,2,sum)}\n                else\n                    {n.risk<-x[[i]]$AtRisk}\n                temp <- cbind(x[[i]]$time, x[[i]]$n.event, n.risk, \n                  x[[i]]$surv)\n                dimnames(temp) <- list(rep(\"\", nrow(temp)), plab)\n                ans[[i]] <- temp\n            }\n            names(ans) <- names(x)\n            oldClass(ans) <- \"summary.survfitr\"\n            attr(ans, \"strata\") <- attr(x, \"strata\")\n        }\n        else {\n            if (is.matrix(x$AtRisk))\n              n.risk<-apply(x$AtRisk,2,sum)\n            else\n              n.risk<-x$AtRisk\n            temp <- cbind(x$time, x$n.event, n.risk, x$surv)\n            dimnames(temp) <- list(rep(\"\", nrow(temp)), plab)\n            ans <- temp\n        }\n    }\n    else {\n        plab <- c(\"time\", \"n.event\", \"n.risk\", \"surv\", \"std.error\")\n        if (!is.null(attr(x, \"strata\"))) {\n            ans <- list(NA)\n            for (i in 1:attr(x, \"strata\")) {\n                if (is.matrix(x[[i]]$AtRisk))\n                    {n.risk<-apply(x[[i]]$AtRisk,2,sum)}\n                else\n                    {n.risk<-x[[i]]$AtRisk}\n                temp <- cbind(x[[i]]$time, x[[i]]$n.event, n.risk, \n                  x[[i]]$surv, x[[i]]$std.error)\n                dimnames(temp) <- list(rep(\"\", nrow(temp)), plab)\n                ans[[i]] <- temp\n            }\n            names(ans) <- names(x)\n            oldClass(ans) <- \"summary.survfitr\"\n            attr(ans, \"strata\") <- attr(x, \"strata\")\n        }\n        else {\n            if (is.matrix(x$AtRisk))\n              n.risk<-apply(x$AtRisk,2,sum)\n            else\n              n.risk<-x$AtRisk\n            temp <- cbind(x$time, x$n.event, n.risk, x$surv, \n                x$std.error)\n            dimnames(temp) <- list(rep(\"\", nrow(temp)), plab)\n            ans <- temp\n        }\n    }\n    ans\n}\n\n\n\n\"print.summary.survfitr\" <-\nfunction (x,scale=1,digits = max(options()$digits - 4, 3), ...) \n{\n  savedig <- options(digits = digits)\n  on.exit(options(savedig))\n\nif(is.null(attr(x,\"strata\")))\n  {\n   # no strata \n    cat(\"\\n\")\n    temp<-x\n    oldClass(temp)<-NULL\n    print(temp)\n    cat(\"\\n\")\n  }\n\nelse\n { \n  for (i in 1:attr(x,\"strata\"))\n    {\n     cat(\"\\n      Group=\",names(x)[i])\n     cat(\"\\n\")\n     print(x[[i]])\n     cat(\"\\n\")\n    }\n }\n invisible(x)\n}\n\n",
    "created" : 1505201438536.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1758151687",
    "id" : "CB6C578A",
    "lastKnownWriteTime" : 1505209389,
    "last_content_update" : 1505209389556,
    "path" : "C:/Juan/CREAL/GitHub/survrec/R/survrec.R",
    "project_path" : "R/survrec.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}