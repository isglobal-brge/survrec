{
    "collab_server" : "",
    "contents" : "#' Register Native Routines\n#'\n#' Discover and register native routines in a package.\n#' Functions to be registered should be prefixed with the\n#' `// [[export(<methods>)]]` attribute.\n#'\n#' @param package The path to an \\R package.\n#' @param prefix The prefix to assign to the \\R objects\n#'   generated that map to each routine.\n#' @param dynamic.symbols Boolean; should dynamic symbol lookup\n#'   be enabled?\n#'\nregister_routines <- function(package = \".\",\n                              prefix = \"C_\",\n                              dynamic.symbols = FALSE)\n{\n  # read DESCRIPTION file\n  desc_path <- file.path(package, \"DESCRIPTION\")\n  if (!file.exists(desc_path)) {\n    fmt <- \"no DESCRIPTION at path '%s'\"\n    stop(sprintf(fmt, desc_path))\n  }\n  desc <- read.dcf(desc_path, all = TRUE)\n  pkg_name <- desc$Package\n  \n  # find C, C++ files in package\n  srcfiles <- list.files(\n    package,\n    pattern = \"\\\\.(?:h|c|cc|cpp)$\",\n    full.names = TRUE,\n    recursive = TRUE\n  )\n  \n  # discover routines in these files\n  routines <- unlist(\n    lapply(srcfiles, discover_routines),\n    recursive = FALSE\n  )\n  \n  # generate prototypes based on routines\n  prototypes <- generate_prototypes(routines)\n  \n  # separate routines based on declared export type\n  call_routines <- external_routines <- list()\n  lapply(routines, function(routine) {\n    \n    # extract registration text and discover the interface\n    pieces <- strsplit(routine$registration, \"\\\\[\\\\[|\\\\]\\\\]\")[[1]]\n    code <- utils::tail(pieces, 1)\n    parsed <- tryCatch(\n      parse(text = code)[[1]],\n      error = function(e) {\n        warning(\"failed to parse registration comment '\", routine$registration, \"'\")\n        next\n      }\n    )\n    \n    interface <- as.character(parsed[[2]])\n    if (interface == \".Call\") {\n      call_routines[[length(call_routines) + 1]] <<- routine\n    } else if (interface == \".External\") {\n      external_routines[[length(external_routines) + 1]] <<- routine\n    } else {\n      warning(\"unrecognized / unsupported interface '\", interface, \"'\")\n      next\n    }\n  })\n  \n  # generate method definitions for each\n  call_methods <- generate_call_methods(call_routines, prefix = prefix)\n  external_methods <- generate_external_methods(external_routines, prefix = prefix)\n  \n  # generate initialization routine\n  r_init <- generate_r_init(pkg_name = pkg_name,\n                            call_methods = call_methods,\n                            external_methods = external_methods,\n                            dynamic_symbols = dynamic.symbols)\n  \n  # generate script\n  script <- c(\n    \"// This file was automatically generated.\",\n    \"\",\n    \"#include <R.h>\",\n    \"#include <Rinternals.h>\",\n    \"#include <R_ext/Rdynload.h>\",\n    \"\",\n    prototypes,\n    \"\",\n    call_methods,\n    \"\",\n    external_methods,\n    \"\",\n    r_init\n  )\n  \n  # write to init file\n  init_path <- sub(\"^\\\\./\", \"\", file.path(package, sprintf(\"src/%s-init.c\", pkg_name)))\n  writeLines(script, init_path, sep = \"\\n\")\n  message(\"* Wrote registration metadata to '\", init_path, \"'\")\n  \n  # remind about .registration = TRUE\n  check_namespace_symbol_registration(package)\n  invisible(init_path)\n}\n\ndiscover_routines <- function(file) {\n  contents <- readBin(file, what = raw(), n = file.info(file)$size)\n  \n  # find routines for registration\n  re_registration <- \"//[[:space:]*]\\\\[\\\\[export\"\n  if (length(contents) < re_registration)\n    return(list())\n  \n  matches <- grepRaw(re_registration, contents, all = TRUE)\n  lapply(matches, function(match) {\n    \n    # find bounds for function prototype\n    start <- grepRaw(\"\\n\",    contents, offset = match) + 1\n    end   <- grepRaw(\"\\\\{|;\", contents, offset = start) - 1\n    \n    # extract the routine type\n    registration <- rawToChar(contents[match:(start - 2)])\n    \n    # extract all 'SEXP .*' pieces of function\n    prototype <- rawToChar(contents[start:end])\n    m <- gregexpr(\"SEXP[[:space:]+]([[:alnum:]_])+\", prototype)\n    names <- regmatches(prototype, m)[[1]]\n    \n    list(\n      registration = registration,\n      prototype = prototype,\n      name = names[[1]],\n      arguments = names[-1L]\n    )\n    \n  })\n  \n}\n\ncheck_namespace_symbol_registration <- function(package = \".\") {\n  \n  # check for namespace file\n  ns_path <- file.path(package, \"NAMESPACE\")\n  if (!file.exists(ns_path))\n    return(invisible(FALSE))\n  \n  # try parsing the namespace\n  ns <- parse(ns_path)\n  \n  # try finding a call to 'useDynLib(pkg, .registration = TRUE)'\n  for (entry in ns) {\n    if (identical(entry[[1]], as.name(\"useDynLib\"))) {\n      nm <- names(entry)\n      idx <- which(nm == \".registration\")\n      if (length(idx) != 1)\n        break\n      \n      if (isTRUE(entry[[idx]]))\n        return(invisible(TRUE))\n    }\n  }\n  \n  invisible(FALSE)\n}\n\ngenerate_prototypes <- function(routines) {\n  # TODO: we assume only SEXP interfaces here\n  vapply(routines, function(routine) {\n    arglist <- paste(rep(\"SEXP\", length(routine$arguments)), collapse = \", \")\n    sprintf(\"%s(%s);\", routine$name, arglist)\n  }, character(1))\n}\n\ngenerate_call_methods <- function(routines, prefix = \"C_\") {\n  \n  # for each routine, generate a registration line\n  fmt <- '{\"%s\", (DL_FUNC) &%s, %i},'\n  lines <- vapply(routines, function(routine) {\n    name <- utils::tail(strsplit(routine$name, \"[[:space:]+]\")[[1]], 1)\n    prefixed_name <- paste0(prefix, name)\n    n <- length(routine$arguments)\n    sprintf(fmt, prefixed_name, name, n)\n  }, character(1))\n  \n  # indent, add commas, add null entry at end\n  lines <- c(lines, \"{NULL, NULL, 0}\")\n  \n  c(\n    \"static R_CallMethodDef callMethods[] = {\",\n    paste0(\"\\t\", lines),\n    \"};\"\n  )\n  \n}\n\ngenerate_external_methods <- function(routines, prefix = \"C_\") {\n  # TODO\n  character()\n}\n\ngenerate_r_init <- function(pkg_name,\n                            call_methods,\n                            external_methods,\n                            dynamic_symbols)\n{\n  r_register_routines <- sprintf(\n    \"\\tR_registerRoutines(info, %s, %s, %s, %s);\",\n    \"NULL\",\n    if (length(call_methods)) \"callMethods\" else \"NULL\",\n    \"NULL\",\n    if (length(external_methods)) \"externalMethods\" else \"NULL\"\n  )\n  \n  fmt <- paste(\n    \"void R_init_%s(DllInfo* info) {\",\n    r_register_routines,\n    \"\\tR_useDynamicSymbols(info, %s);\",\n    \"}\",\n    sep = \"\\n\", collapse = \"\\n\"\n  )\n  \n  sprintf(fmt, pkg_name, if (dynamic_symbols) \"TRUE\" else \"FALSE\")\n  \n}",
    "created" : 1505215233481.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "3211737869",
    "id" : "92D4306C",
    "lastKnownWriteTime" : 32088649863725103,
    "last_content_update" : 1505215235422,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}