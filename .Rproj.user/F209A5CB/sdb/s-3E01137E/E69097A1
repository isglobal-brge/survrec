{
    "collab_server" : "",
    "contents" : "c\nc\nc     Main program\nc\nc\n\n\tsubroutine bootMedian(n,m,times,sfailed,ntimes,cen,tau,\n     *\t                      nSimBoot,plan,percentil,median)\n\n\nc       Percentil que buscamos. Para no cambiar los programas llamo median al\nc                               resultado aunque le paso el parametro percentil\n\n\n\t implicit none\n         integer n,ntimes,maxtimes\n\t double precision nu,theta\n\t \n\t parameter (maxtimes=800)\t \n\t \n\t integer m(n),i,j,count\n\t double precision tau(n),control,Tacum,timesRan,rexp\n\t double precision times(ntimes),cen(n)\n\n\t double precision timesPSH(maxtimes),sfailed(ntimes) \n\n         integer mBoot(n),ntimesBoot,numdistinct,numdistinctFn\n\t double precision timesBoot(maxtimes), sfailedBoot(maxtimes)\n\t double precision cenBoot(n),distinct(maxtimes)\n\t double precision distinctFn(maxtimes),medianPSH,medianWC\n\t double precision medianMLE,percentil\n\t integer numdeaths(maxtimes),AtRisk(n,maxtimes)\n\t \n\t double precision FnPSH(maxtimes),FnWC(maxtimes)\n\t \n\t integer ss,nSimBoot\n\n       \n         double precision median(nSimBoot),alphaMLE(nSimBoot)\n         integer status,plan\t \n     \t \n\t  \n\t double precision rgam,alphaTheor,alpha,lambda0(maxtimes),\n     *   lambda(maxtimes),alphaIni,FnMLE(maxtimes),survMLE(maxtimes),\n     *   survF0(maxtimes),FnF0(maxtimes),varZ, \n     *   lambdaIni(maxtimes),lambda0Ini(maxtimes)\n     \n         integer aux,sample2    \n     \n         \t \n         call DistinctFailed(n,m,times,sfailed,ntimes,\n     *              cen,numdistinctFn,distinctFn,numdeaths,AtRisk)\n         \n\n         call pshFn(n,numdistinctFn,AtRisk,distinctFn,numdeaths,\n     *       FnPSH) \n     \n     \n        call wcFn(n,m,times,ntimes,cen,numdistinctFn,\n     *       distinctFn,AtRisk,FnWC)\n\n        \n        if (FnWC(numdistinctFn).lt.1.d0) then\n          numdistinctFn=numdistinctFn+1\n          FnWC(numdistinctFn)=1.d0\n          FnPSH(numdistinctFn)=1.d0\n          distinctFn(numdistinctFn)=1.d30\n        end if\n        \n        \n        \n        if ((plan.eq.6).or.(plan.eq.7)) then\t   \nc\nc  MLE Frailty procedure  \nc\t   \n                              \n         call mleALL(n,m,numdistinctFn,distinctFn,numdeaths,1,\n     *\t   AtRisk,lambda0Ini,lambdaIni,alphaIni,survMLE,\n     *     percentil,medianMLE,status)  \n  \n        end if\n           \n\nc\nc  Inicio de las muestras bootstrap   \nc\n\n           \n      do ss=1,nSimBoot\n       \n\t \n       if (plan.eq.1) then \nc\nc       Boostrap plan I\nc         \n           call boot1(n,m,tau,ntimes,times,\n     *        \t  mBoot,ntimesBoot,timesBoot,cenBoot)\n\t  \n\t  \n\t   do i=1,ntimesBoot\n            sfailedBoot(i)=timesBoot(i)\n\t   end do\n\n\t   call sorter(sfailedBoot,ntimesBoot)\n \n  \n         call DistinctFailed(n,mBoot,timesBoot,sfailedBoot,ntimesBoot,\n     *              cenBoot,numdistinct,distinct,numdeaths,AtRisk)\n            \n     \n         call psh(n,numdistinct,AtRisk,distinct,numdeaths,\n     *               percentil,medianPSH) \n         \n\t    \n\t   median(ss)=medianPSH\n\t    \n   \t \n\n       elseif (plan.eq.2) then \nc\nc       Boostrap plan II nuevo\nc         \n \n\t   call boot6(n,m,tau,numdistinctFn,distinctFn,FnPSH,\n     *        \t  mBoot,ntimesBoot,timesBoot,cenBoot)\n          \n           \n\t   do i=1,ntimesBoot\n            sfailedBoot(i)=timesBoot(i)\n\t   end do\n\n\t   call sorter(sfailedBoot,ntimesBoot)\n\n   \t   call DistinctFailed(n,mBoot,timesBoot,sfailedBoot,ntimesBoot,\n     *              cenBoot,numdistinct,distinct,numdeaths,AtRisk)\n\n         call psh(n,numdistinct,AtRisk,distinct,numdeaths,\n     *            percentil,medianPSH) \n       \n\t   median(ss)=medianPSH\n\n        \t   \n       elseif (plan.eq.3) then\nc\t \nc       Boostrap plan III nuevo\nc         \n\n\t   call boot7(n,m,tau,numdistinctFn,distinctFn,FnPSH,\n     *        \t  mBoot,ntimesBoot,timesBoot,cenBoot)\n  \n\n\t   do i=1,ntimesBoot\n           sfailedBoot(i)=timesBoot(i)\n\t   end do\n       \n\t   call sorter(sfailedBoot,ntimesBoot)\n      \n         call DistinctFailed(n,mBoot,timesBoot,sfailedBoot,ntimesBoot,\n     *              cenBoot,numdistinct,distinct,numdeaths,AtRisk)\n\n         call psh(n,numdistinct,AtRisk,distinct,numdeaths,\n     *            percentil,medianPSH) \n\t   \n    \t   median(ss)=medianPSH\n\n       elseif (plan.eq.4) then\nc\nc       Boostrap plan IV nuevo\nc\n\t \n\t   \n\t   call boot6(n,m,tau,numdistinctFn,distinctFn,FnWC,\n     *        \t  mBoot,ntimesBoot,timesBoot,cenBoot)\n       \n\t   \n\t   do i=1,ntimesBoot\n           sfailedBoot(i)=timesBoot(i)\n\t   end do\n\n\t   call sorter(sfailedBoot,ntimesBoot)\n\n  \t   call DistinctFailed(n,mBoot,timesBoot,sfailedBoot,ntimesBoot,\n     *              cenBoot,numdistinct,distinct,numdeaths,AtRisk)\n     \n         \n         call wc(n,mBoot,timesBoot,ntimesBoot,cenBoot,numdistinct,\n     *\t       distinct,AtRisk,percentil,medianWC) \n\t   \n\t   median(ss)=medianWC\n        \n       \t   \n       elseif (plan.eq.5) then \nc\nc       Boostrap plan V nuevo\nc         \n\n\t   call boot7(n,m,tau,numdistinctFn,distinctFn,FnWC,\n     *        \t  mBoot,ntimesBoot,timesBoot,cenBoot)\n\t  \n\t   do i=1,ntimesBoot\n            sfailedBoot(i)=timesBoot(i)\n\t   end do\n       \n\t   call sorter(sfailedBoot,ntimesBoot)\n      \n         call DistinctFailed(n,mBoot,timesBoot,sfailedBoot,ntimesBoot,\n     *              cenBoot,numdistinct,distinct,numdeaths,AtRisk)\n\n        call wc(n,mBoot,timesBoot,ntimesBoot,cenBoot,numdistinct,\n     *\t       distinct,AtRisk,percentil,medianWC) \n\t   \t   \n        median(ss)=medianWC       \n\n       elseif (plan.eq.6) then\nc\nc       Boostrap plan VI nuevo (Semiparametric)\nc\n\t      \n\t   call boot8(n,m,tau,real(alphaIni),lambdaIni,numdistinctFn,\n     *\t   distinctFn,mBoot,ntimesBoot,timesBoot,cenBoot,varZ)\n         \n         \t            \t   \n\t   do i=1,ntimesBoot\n           sfailedBoot(i)=timesBoot(i)\n\t   end do\n\n\t   call sorter(sfailedBoot,ntimesBoot)\n\n   \t   call DistinctFailed(n,mBoot,timesBoot,sfailedBoot,ntimesBoot,\n     *              cenBoot,numdistinct,distinct,numdeaths,AtRisk)\n     \n                       \nc       En caso que no quiera buscar la semilla\t   \nc\t   alpha=1/varZ   y  0 en mleALL\n\t   \n\t   \n\t   call mleALL(n,mBoot,numdistinct,distinct,numdeaths,1,\n     *\t   AtRisk,lambda0,lambda,alpha,survMLE,percentil,medianMLE,\n     *    status)  \n           \n         \n           median(ss)=medianMLE\n\t   alphaMLE(ss)=alpha\n        \n       else\nc\nc       Boostrap plan VII nuevo (Semiparametric)\nc\n\t   \n         call boot9(n,m,tau,real(alphaIni),lambdaIni,numdistinctFn,\n     *\t   distinctFn,mBoot,ntimesBoot,timesBoot,cenBoot,varZ)\n             \n         \t   \n\t   do i=1,ntimesBoot\n           sfailedBoot(i)=timesBoot(i)\n\t   end do\n\n\t   call sorter(sfailedBoot,ntimesBoot)\n\n   \t   call DistinctFailed(n,mBoot,timesBoot,sfailedBoot,ntimesBoot,\n     *              cenBoot,numdistinct,distinct,numdeaths,AtRisk)\n     \n        \nc       En caso que no quiera buscar la semilla\t   \nc\t   alpha=1/varZ     y 0 en mleALL\n\t   \n\t   \n        call mleALL(n,mBoot,numdistinct,distinct,numdeaths,1,\n     *\t   AtRisk,lambda0,lambda,alpha,survMLE,percentil,medianMLE,\n     *    status)  \n\n         \n         median(ss)=medianMLE\n\t alphaMLE(ss)=alpha\n     \n       end if \n\t\n\tend do \n      \n\t\n      end subroutine bootMedian\n\n      \n\nc\nc\nc     Auxiliar functions \nc\nc\n\n\n      function sample(m)\n\t \n\t implicit none\n\t integer sample,m,taux\n         double precision aux\nc        real aux,rand\n\t        \nc        call DRNUN(1,aux)\t  \nc        call random_number(aux)\n         \nc        call system_clock(taux)       \nc        aux=rand(taux)\n        \n         aux=rand(0)\n         \n        sample=int(aux*m)+1\n        return\n\n      end function\n\n\n       function sample2(n,prob)\n\t  \n\t  implicit none\n\t  integer n,sample2,taux\n\t  double precision prob(n)\n          double precision aux\nc\t  real aux,rand\n        \nc\tcall DRNUN(1,aux)\nc       call random_number(aux)\t  \n\nc       call system_clock(taux)       \nc       aux=rand(taux)\n        \n        aux=rand(0)\n\t  \n        sample2=1\n\tdo while ((prob(sample2).lt.aux).and.(sample2.le.n))\n          sample2=sample2+1\n\tend do\n\t \n\treturn\n\t \n       end function\n\n\n\nc\nc   Bootstrap plans\nc\n\n \n      subroutine boot1(n,m,tau,ntimes,times,\n     *               \t  mBoot,ntimesBoot,timesBoot,cenBoot)\n       implicit none\n       integer n,ntimes\n\t integer m(n),i,j,k,l,r,sample,ntimesBoot,pos\n\t integer mBoot(n)\n\t double precision tau(n),times(ntimes),control\n\t double precision timesBoot(800),cenBoot(n)\n\t \n\t \n\t ntimesBoot=0\n\t\n\t  do i=1,n\n\t   \n\t   if (i.eq.1) then\n\t    r=1\n\t\tdo while ((r.le.n).and.(m(r).eq.0))\n\t\t   r=r+1\n\t    end do\n\t    mBoot(i)=m(r)\n\t    j=r\n\t    if (mBoot(i).eq.0) then\n           write(*,*) \"cagada todos son cero\"\n\t    end if\n\t   else\n\t     j=sample(n)\n\t     mBoot(i)=m(j)\n\t   end if\n\n\t   pos=0\n\t   do k=1,j-1\n\t    pos=pos+m(k)\n         end do\n        \n\t   control=0.0d0\n\t   do l=1,mBoot(i)\n\t    timesBoot(l+ntimesBoot)=times(pos+l)\n\t    control=control+times(pos+l)\n\t   end do    \n\n         ntimesBoot=ntimesBoot+mBoot(i) \n\t   cenBoot(i)=tau(j)-(control)\n\t          \n\t  end do\n      \n\tend subroutine\n\n       subroutine boot6(n,m,tau,ntimes,times,prob,\n     *\t              mBoot,ntimesBoot,timesBoot,cenBoot)\n       implicit none\n       integer n,ntimes\n\t integer m(n),i,j,count,sample,sample2\n\t integer mBoot(n),ntimesBoot\n\t double precision tau(n),times(ntimes),prob(ntimes)\n\t double precision control,controlOld\n\t double precision timesBoot(800),cenBoot(n)\n\t \n         ntimesBoot=0\n\t do i=1,n\n        \n\t  count=0\n\t  j=sample2(ntimes,prob)\n\t  control=times(j)\n\n\t  do while (control.le.tau(i))\n  \t   timesBoot(1+count+ntimesBoot)=times(j)\n\t   count=count+1\n\t   j=sample2(ntimes,prob)\n\t   control=control+times(j)\n\t  end do\n\t  \n\t  mBoot(i)=count\n\t  ntimesBoot=ntimesBoot+count\n\t  \n\t  cenBoot(i)=tau(i)-(control-times(j))\n\t end do\n\t\n\tend subroutine\n\n      subroutine boot7(n,m,tau,ntimes,times,prob,\n     *\t              mBoot,ntimesBoot,timesBoot,cenBoot)\n       implicit none\n       integer n,ntimes\n\t integer m(n),i,j,l,r,count,sample,sample2\n\t integer mBoot(n),ntimesBoot,bucle\n\t double precision tau(n),times(ntimes),prob(ntimes),control\n\t double precision timesBoot(800),cenBoot(n),tau0\n\t \n\t \n\t ntimesBoot=0\n\t bucle=0\n\t do while ((ntimesBoot.eq.0).and.(bucle.lt.100))\n\n\t  do i=1,n\n\t   \t   \n\t   l=sample(n)\n         tau0=tau(l)\n\n\t   count=0\n\t   j=sample2(ntimes,prob)\n\t   control=times(j)\n\t   do while (control.le.tau0)\n  \t    timesBoot(1+count+ntimesBoot)=times(j)\n\t    count=count+1\n\t    j=sample2(ntimes,prob)\n\t    control=control+times(j)\n\t   end do\n\n\t   mBoot(i)=count\n\t   ntimesBoot=ntimesBoot+count\n         cenBoot(i)=tau0-(control-times(j))\n\t  end do\n\t  bucle=bucle+1\n\t end do\n\t\n\tend subroutine\n\n\n      subroutine boot8(n,m,tau,alpha,lambda0,numdistinct,distinct,\n     *\t              mBoot,ntimesBoot,timesBoot,cenBoot,varZ)\n       implicit none\n       integer n,numdistinct\n\t integer m(n),i,j,k,count,sample,sample2\n\t integer mBoot(n),ntimesBoot\n\t double precision tau(n),control,controlOld\n\t double precision timesBoot(800),cenBoot(n)\n\n\t double precision lambda0(numdistinct),distinct(numdistinct)\n\t double precision survF0(numdistinct),FnF0(numdistinct)\n\t double precision mm,varZ,Z(n),dsum  \n\n\t real random_gamma,rgam,alpha\n  \n\t ntimesBoot=0\n\t do i=1,n\n        \n\nc\t   call drngam(1,alpha,rgam)\n            \n         rgam=random_gamma(alpha)\n\n         Z(i)=((1/alpha)*(rgam))\n        \n\t   do k=1,numdistinct\n   \t      survF0(k)=exp(-Z(i)*dsum(lambda0,numdistinct,k))\n\t   end do\n\t   \n         \n\t   do k=1,numdistinct\n           FnF0(k)=1-survF0(k)\n\t   end do\n\t  \n\t   \t  \n\t  j=sample2(numdistinct,FnF0)\n\t  control=distinct(j)\n\t     \n\t  count=0\n\t  \n\n\t  do while (control.le.tau(i))\n  \t   timesBoot(1+count+ntimesBoot)=distinct(j)\n\t   count=count+1\n\t   j=sample2(numdistinct,FnF0)\n\t   control=control+distinct(j)\n\t  end do\n\t  \n\t  mBoot(i)=count\n\t  ntimesBoot=ntimesBoot+count\n\t  \n\t  cenBoot(i)=tau(i)-(control-distinct(j))\n\t end do\n\t \n\t   mm=dsum(Z,n,n)/n\n         varZ=0\n\t   do i=1,n\n\t    varZ=varZ+(Z(i)-mm)**2\n\t   end do\n\n\tend subroutine\n\n      subroutine boot9(n,m,tau,alpha,lambda0,numdistinct,distinct,\n     *\t              mBoot,ntimesBoot,timesBoot,cenBoot,varZ)\n       implicit none\n       integer n,numdistinct,bucle,l\n\t integer m(n),i,j,k,count,sample,sample2\n\t integer mBoot(n),ntimesBoot\n\t double precision tau(n),control,controlOld,tau0\n\t double precision timesBoot(800),cenBoot(n)\n\n\t double precision lambda0(numdistinct),distinct(numdistinct)\n\t double precision survF0(numdistinct),FnF0(numdistinct)\n\t double precision mm,varZ,Z(n),dsum\n\n\t      \n\t real random_gamma,rgam,alpha\n\n       ntimesBoot=0\n\t bucle=0\n\t do while ((ntimesBoot.eq.0).and.(bucle.lt.100))\n\n\t  do i=1,n\n\t   \t   \n\t   l=sample(n)\n         tau0=tau(l)\n \n\nc\t   call drngam(1,alpha,rgam)\n\t   rgam=random_gamma(alpha)\n\t   \n         Z(i)=((1/alpha)*(rgam))\n        \n\t   do k=1,numdistinct\n   \t      survF0(k)=exp(-Z(i)*dsum(lambda0,numdistinct,k))\n\t   end do\n\t   \n         \n\t   do k=1,numdistinct\n           FnF0(k)=1-survF0(k)\n\t   end do\n\t  \n\t   \t  \n\t  j=sample2(numdistinct,FnF0)\n\t  control=distinct(j)\n\t     \n\t  count=0\n\t  \n\n\t  do while (control.le.tau0)\n  \t   timesBoot(1+count+ntimesBoot)=distinct(j)\n\t   count=count+1\n\t   j=sample2(numdistinct,FnF0)\n\t   control=control+distinct(j)\n\t  end do\n\t  \n\t  mBoot(i)=count\n\t  ntimesBoot=ntimesBoot+count\n\t  \n\t  cenBoot(i)=tau0-(control-distinct(j))\n\t  end do\n\t  bucle=bucle+1\n\t end do\n\n\t \n\t   mm=dsum(Z,n,n)/n\n         varZ=0\n\t   do i=1,n\n\t    varZ=varZ+(Z(i)-mm)**2\n\t   end do\n\n\tend subroutine\n\n\n\n      subroutine pshFn(n,numdistinct,AtRisk,distinct,numdeaths,Fn)\n\n\n\t implicit none\n\n\t integer n,numdistinct,i,j,pos\n\t integer AtRisk(n,numdistinct),numdeaths(numdistinct)\n\t double precision Fn(numdistinct),distinct(numdistinct)\n\t double precision AtRiskOk(numdistinct),surv(numdistinct)\n\n\n\t do i=1,numdistinct\n        AtRiskOK(i)=0.d0\n\t end do\n\t \n\t do i=1,numdistinct\n\t  do j=1,n\n\t   AtRiskOK(i)=AtRiskOk(i)+AtRisk(j,i)\n        end do\n       end do\n\n              \n       surv(1)=1-(numdeaths(1)/AtRiskOk(1))\n\n\t do i=2,numdistinct\n         surv(i)=surv(i-1)*(1-(numdeaths(i)/AtRiskOk(i)))\n\t end do\n       \n       \t\n       \n       \n       do i=1,numdistinct\n        Fn(i)=1-surv(i)         \n       end do\n       \n       \n       \n\n      end subroutine\t\n\n      \n\n      subroutine wcFn(n,m,failed,nfailed,censored,numdis,distinct,\n     .               AtRisk,Fn)\n\n      implicit none\n\n      integer n,nfailed\n      integer m(n),numdis\n\n      double precision failed(nfailed),censored(n)\n      double precision distinct(numdis)\n      integer vAtRisk(n*numdis)\n      integer AtRisk(n,numdis)\n\n      integer i,j,l,jj,mcumold,mcum\n\n      double precision mstar(n)\n      double precision dstar(n,numdis),rstar(n,numdis),ple(numdis)\n\n      double precision Fn(numdis),dstarcum(800),rstarcum(800)\n\n      \n      do i=1,n\n\tdo j=1,numdis\n       dstar(i,j)=0\n\tend do\n\tend do\n\n      mcum = 0\n\n      do i=1,n\n        mcumold = mcum\n        mcum = mcum + m(i)\n\n        if(m(i) .eq. 0) then\n           mstar(i) = 1.d0\n        else\n           mstar(i) = dfloat(m(i))\n        endif\n\n        do l=1,numdis\n         if(m(i).gt.0) then\n          do jj=mcumold+1,mcum\n           if(failed(jj) .eq.  distinct(l)) then\n              dstar(i, l) = dstar(i, l) + 1\n           endif\n          end do\n\n          if(censored(i) .ge.  distinct(l)) then\n              rstar(i, l) = dfloat(AtRisk(i, l)) - 1.d0\n          else\n              rstar(i,l) = dfloat(AtRisk(i,l))\n          endif\n         else\n           rstar(i, l) = dfloat(AtRisk(i, l))\n         endif\n        end do\n      end do\n\n      do 40 j=1,numdis\n\t\tdstarcum(j)=0.d0\n\t\trstarcum(j)=0.d0\n\tdo 45 i=1,n\n\t\tdstarcum(j)=dstarcum(j) + dstar(i,j)/(mstar(i))\n\t\trstarcum(j)=rstarcum(j) + rstar(i,j)/(mstar(i))\n45\tcontinue\n40\tcontinue\nc\n\t\t\n\tple(1) = 1.d0 - dstarcum(1)/rstarcum(1)\n\tdo 50 l=2,numdis\n\t   ple(l)=ple(l-1)*(1.d0-dstarcum(l)/rstarcum(l))\n50\tcontinue\n\n       do i=1,numdis\n        Fn(i)=1.d0-ple(i)\n\t end do\n     \n      end subroutine\n\n\n\n\n       subroutine psh(n,numdistinct,AtRisk,distinct,numdeaths,\n     *            percentil,medianPSH) \n\n\n\t implicit none\n\n\t integer n,numdistinct,i,j,pos\n\t integer AtRisk(n,numdistinct),numdeaths(numdistinct)\n\t double precision survfuncPSH(numdistinct),distinct(numdistinct)\n\t double precision AtRiskOk(numdistinct),medianPSH,percentil\n\n       do i=1,numdistinct\n\t  AtRiskOK(i)=0.d0\n       end do\n\n\t do i=1,numdistinct\n\t  do j=1,n\n\t   AtRiskOK(i)=AtRiskOK(i)+AtRisk(j,i)\n        end do \n       end do\n\n       survfuncPSH(1)=1-(numdeaths(1)/AtRiskOk(1))\n\n\t do i=2,numdistinct\n         survfuncPSH(i)=survfuncPSH(i-1)*\n     .\t              (1-(numdeaths(i)/AtRiskOk(i)))\n\t end do\n\t\n         \t \t \n\t if (survfuncPSH(numdistinct).le.percentil) then\n\t  pos=1\n\t  do while (survfuncPSH(pos).gt.percentil)\n           pos=pos+1\n\t  end do\n\t  medianPSH=distinct(pos)\n\t else\n\t  medianPSH=-1.0d0\n\t end if \n      \n\tend subroutine\t\n         \n\n\n      subroutine wc(n,m,failed,nfailed,censored,numdis,distinct,\n     .               AtRisk,percentil,medianWC)\n\n      implicit none\n\n      integer n,nfailed\n      integer m(n),numdis\n\n      double precision failed(nfailed),censored(n)\n      double precision distinct(numdis)\n      integer AtRisk(n,numdis)\n\n      integer i,j,l,jj,mcumold,mcum,pos\n\n      double precision mstar(n)\n      double precision dstar(n,numdis),rstar(n,numdis),ple(numdis)\n\n      double precision dstarcum(800),rstarcum(800),medianWC,percentil\n\n      do i=1,n\n\tdo j=1,numdis\n       dstar(i,j)=0.0d0\n\tend do\n\tend do\n\n      mcum = 0\n\n      do i=1,n\n        mcumold = mcum\n        mcum = mcum + m(i)\n\n        if(m(i) .eq. 0) then\n           mstar(i) = 1.d0\n        else\n           mstar(i) = dfloat(m(i))\n        endif\n\n        do l=1,numdis\n         if(m(i).gt.0) then\n          do jj=mcumold+1,mcum\n           if(failed(jj) .eq.  distinct(l)) then\n              dstar(i, l) = dstar(i, l) + 1\n           endif\n          end do\n\n          if(censored(i) .ge.  distinct(l)) then\n              rstar(i, l) = dfloat(AtRisk(i, l)) - 1.d0\n          else\n              rstar(i,l) = dfloat(AtRisk(i,l))\n          endif\n         else\n\t       rstar(i, l) = dfloat(AtRisk(i, l))\n         endif\n        end do\n      end do\n\n      do 40 j=1,numdis\n\t\tdstarcum(j)=0.d0\n\t\trstarcum(j)=0.d0\n\tdo 45 i=1,n\n\t\tdstarcum(j)=dstarcum(j) + dstar(i,j)/mstar(i)\n\t\trstarcum(j)=rstarcum(j) + rstar(i,j)/mstar(i)\n\t\n      \n45    continue\n40\tcontinue\nc\n\n\tple(1) = 1.0d0 - (dstarcum(1)/rstarcum(1))\n\tdo 50 l=2,numdis\n\t   ple(l)=ple(l-1)*(1.0d0-(dstarcum(l)/rstarcum(l)))\n50\tcontinue\n\n\t \n\t if (ple(numdis).le.percentil) then\n\t  pos=1\n\t  do while (ple(pos).gt.percentil)\n           pos=pos+1\n\t  end do\n      \t  medianWC=distinct(pos)\n      \t else\n      \t  medianWC=-1.0d0 \n      \t end if \n\n       end subroutine\n\n\n      subroutine mleALL(n,m,numdistinct,distinct,numdeaths,searchProc,\n     *\t   AtRisk,lambda0,lambda,alpha,survMLE,percentil,medianMLE,\n     *    status)  \n\n       implicit none\n\t \n\t integer n,i,j,pos,searchProc\n\t integer m(n),numdistinct\n\t integer numdeaths(numdistinct),AtRisk(n,numdistinct)\n\t double precision distinct(numdistinct),medianMLE\n\n\t double precision alpha_min,alpha_max,alpha,lambda0(numdistinct),\n     *   lambda(numdistinct),survMLE(numdistinct),\n     *   alphadel,alphaseeds(7),AtRiskOK(numdistinct),percentil\n\t integer IER,status,ind\n      \n\n\n         do i=1,numdistinct\n\t   AtRiskOK(i)=0.d0\n         end do\n\n\t do i=1,numdistinct\n\t  do j=1,n\n\t   AtRiskOK(i)=AtRiskOK(i)+AtRisk(j,i)\n          end do \n         end do\n\n\n         do i=1,numdistinct\n          lambda(i)=float(numdeaths(i))/AtRiskOK(i)\n\t    if (lambda(i).eq.0.0d0) then\n             lambda(i)=0.000001d0\n\t     end if\n\t end do\n\t   \n\t do i=1,numdistinct\n\t   lambda0(i)=lambda(i)\n         end do\n         \n\t alpha_min=0.5d0\n\t alpha_max=distinct(numdistinct)\n\n       \n\t if (searchProc.eq.1) then\n\t    call SearchForSeed(n,m,numdistinct,distinct,numdeaths,\n     *\t      AtRisk,lambda,alpha_min,alpha_max,0.000001,alpha,IER)\n\t end if \n\t   \n\t   \n\t alphadel=alpha/4\n\n         alphaseeds(1)=alpha\n\t alphaseeds(2)=alpha-alphadel\n\t alphaseeds(3)=alpha-2*alphadel\n\t alphaseeds(4)=alpha-3*alphadel\n\t alphaseeds(5)=alpha+alphadel\n\t alphaseeds(6)=alpha+2*alphadel\n\t alphaseeds(7)=alpha+3*alphadel\n\t   \n\t status=0\n\t ind=0\n        \n\t do while ((status.eq.0).and.(ind.lt.7))\n\t   ind=ind + 1\n           alpha=alphaseeds(ind)\n         \n           call emalgo(n,m,numdistinct,distinct,numdeaths,\n     *\t\tAtRisk,lambda,alpha,0.00001d0,500,status)\t   \n\t\n\t   \n\t end do \n         \n\n\t call mlevalue(numdistinct,alpha,lambda,survMLE)\n\n\t \n\t if (survMLE(numdistinct).le.percentil) then\n\t  pos=1\n\t  do while (survMLE(pos).gt.percentil)\n           pos=pos+1\n\t  end do\n\t  medianMLE=distinct(pos)\n\t else\n\t  medianMLE=-1.0d0\n\t end if \n\t \n      \n      return \t\n      end subroutine \n\n\n\n\n\n      double precision function dsum(vec,n,k)\n        implicit none \n\t  integer n,k,i\n\t  double precision vec(n)\n\t  dsum=0.d0\n\t  do i=1,k \n         dsum=dsum+vec(i)\n\t  end do\n        return\n\tend function\n      \n      \n\t\n\tINTEGER FUNCTION atpos(v, n, x)\n\n        !     Determines the position of the scalar x, within the vector v\n\n                integer n\n                DOUBLE PRECISION v(n), x\n\n                INTEGER i\n\n                IF (x .LT. v(1)) THEN\n                   atpos = 0\n                   RETURN\n                END IF\n\n                IF (x .GT. v(n)) THEN\n                   atpos = n\n                   RETURN\n                END IF\n\n                DO 100, i=1, n\n                   IF (x-v(i) .GE. 0.0d0) THEN\n                          atpos = i\n                END IF\n\n 100      CONTINUE\n\n                RETURN\n      END\n\n\n      SUBROUTINE sorter(v, n)\n\nC     Sort the vector v, increasingly\n\nC     length of v\n      INTEGER n\n\nC     vector to be sorted\n      DOUBLE PRECISION v(n)\n\n      LOGICAL qdone\n      INTEGER i\n      DOUBLE PRECISION temp\n\n      IF (n .EQ. 1) RETURN\n\n 100  qdone = .TRUE.\n\n      DO 200, i=1, n-1\n\n         IF (v(i) .GT. v(i+1)) THEN\n            qdone = .FALSE.\n            temp = v(i)\n            v(i) = v(i+1)\n            v(i+1) = temp\n         END IF\n\n 200  CONTINUE\n\n      IF (.NOT. qdone) GO TO 100\n\n      RETURN\n      END\n\n!    *************************************\n\n!          Random number functions  \n\n!    *************************************\n\n\n\tFUNCTION random_normal() RESULT(fn_val)\n\nc\t! Adapted from the following Fortran 77 code\nc\t!      ALGORITHM 712, COLLECTED ALGORITHMS FROM ACM.\nc\t!      THIS WORK PUBLISHED IN TRANSACTIONS ON MATHEMATICAL SOFTWARE,\nc\t!      VOL. 18, NO. 4, DECEMBER, 1992, PP. 434-435.\n\nc\t!  The function random_normal() returns a normally distributed pseudo-random\nc\t!  number with zero mean and unit variance.\n\nc\t!  The algorithm uses the ratio of uniforms method of A.J. Kinderman\nc\t!  and J.F. Monahan augmented with quadratic bounding curves.\n\n\tIMPLICIT NONE\n\n        REAL   :: zero = 0.0, half = 0.5, one = 1.0, two = 2.0   \nc     *                          vsmall = TINY(1.0), vlarge = HUGE(1.0)\nc        INTEGER, PARAMETER :: dp = SELECTED_REAL_KIND(12, 60)\n\n      integer taux \t\n\tREAL :: fn_val,rand\n\nc\t!     Local variables\n\tREAL :: s=0.449871, t=-0.386595, a = 0.1960, b = 0.25472\n       REAL :: r1 = 0.27597, r2 = 0.27846, u, v, x, y, q\n\nc\t!     Generate P = (u,v) uniform in rectangle enclosing acceptance region\n\n\tDO\n\nc\t  CALL RANDOM_NUMBER(u)\nc\t  CALL RANDOM_NUMBER(v)\n\nc        call system_clock(taux)       \nc        u=rand(taux)\n         u=rand(0)\n         \nc        call system_clock(taux)\nc        v=rand(taux)\n         v=rand(0)\n\n\t  v = 1.7156 * (v - half)\n\nc\t!     Evaluate the quadratic form\n\t  x = u - s\n\t  y = ABS(v) - t\n\t  q = x**2 + y*(a*y - b*x)\n\nc\t!     Accept P if inside inner ellipse\n\t  IF (q < r1) EXIT\nc\t!     Reject P if outside outer ellipse\n\t  IF (q > r2) CYCLE\nc\t!     Reject P if outside acceptance region\n\t  IF (v**2 < -4.0*LOG(u)*u**2) EXIT\n\tEND DO\n\nc\t!     Return ratio of P's coordinates as the normal deviate\n\tfn_val = v/u\n\tRETURN\n\n\tEND FUNCTION random_normal\n\n\n\nc\t!FUNCTION random_gamma(s,first) RESULT(fn_val)\n\tFUNCTION random_gamma(s) RESULT(fn_val)\n\nc\t! Adapted from Fortran 77 code from the book:\nc\t!     Dagpunar, J. 'Principles of random variate generation'\nc\t!     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9\n\nc\t!     FUNCTION GENERATES A RANDOM GAMMA VARIATE.\nc\t!     CALLS EITHER random_gamma1 (S > 1.0)\nc\t!     OR random_exponential (S = 1.0)\nc\t!     OR random_gamma2 (S < 1.0).\n\nc\t!     S = SHAPE PARAMETER OF DISTRIBUTION (0 < REAL).\n\n      IMPLICIT NONE\n        REAL:: zero = 0.0, half = 0.5, one = 1.0, two = 2.0   \nc     *                          vsmall = TINY(1.0), vlarge = HUGE(1.0)\nc        INTEGER, PARAMETER :: dp = SELECTED_REAL_KIND(12, 60)\n\tREAL random_gamma1,random_gamma2,random_exponential,rand\n\nc                REAL, INTENT(IN)    :: s\n                 REAL::s\nc\t\t!LOGICAL, INTENT(IN) :: first\n\t\tREAL                :: fn_val\n\n\t\tIF (s <= zero) THEN\n\t\t  WRITE(*, *) 'SHAPE PARAMETER VALUE MUST BE POSITIVE'\n\t\t  STOP\n\t\tEND IF\n\n\t\tIF (s > one) THEN\nc\t\t!  fn_val = random_gamma1(s, first)\n\t\t  fn_val = random_gamma1(s)\n\t\tELSE IF (s < one) THEN\nc\t\t!  fn_val = random_gamma2(s, first)\n\t\t  fn_val = random_gamma2(s)\n\t\tELSE\n\t\t  fn_val = random_exponential()\n\t\tEND IF\n\n\t\tRETURN\n\t\tEND FUNCTION random_gamma\n\n\n\nc\t!FUNCTION random_gamma1(s, first) RESULT(fn_val)\n\tFUNCTION random_gamma1(s) RESULT(fn_val)\nc\t! Uses the algorithm in\nc\t! Marsaglia, G. and Tsang, W.W. (2000) `A simple method for generating\nc\t! gamma variables', Trans. om Math. Software (TOMS), vol.26(3), pp.363-372.\n\nc\t! Generates a random gamma deviate for shape parameter s >= 1.\n\n\tIMPLICIT NONE\n        REAL  :: zero = 0.0, half = 0.5, one = 1.0, two = 2.0   \nc     *                          vsmall = TINY(1.0), vlarge = HUGE(1.0)\nc        INTEGER, PARAMETER :: dp = SELECTED_REAL_KIND(12, 60)\n         REAL random_normal \n      \nc        REAL, INTENT(IN)    :: s\n         REAL:: s\nc\t!LOGICAL, INTENT(IN) :: first\n\tREAL                :: fn_val\n\nc\t! Local variables\nc        REAL, SAVE  :: c, d\n        REAL  :: c, d\n\tREAL        :: u, v, x,rand\n      integer taux\n\nc\t!IF (first) THEN\n\t  d = s - one/3.\n\t  c = one/SQRT(9.0*d)\nc\t!END IF\n\nc\t! Start of main loop\n\tDO\n\nc\t! Generate v = (1+cx)^3 where x is random normal; repeat if v <= 0.\n\n\t  DO\n\t    x = random_normal()\n\t    v = (one + c*x)**3\n\t    IF (v > zero) EXIT\n\t  END DO\n\nc\t! Generate uniform variable U\n\nc       CALL RANDOM_NUMBER(u)\n      \nc        call system_clock(taux)       \nc        u=rand(taux)\n         u=rand(0)\n\t  \n        IF (u < one - 0.0331*x**4) THEN\n\t    fn_val = d*v\n\t    EXIT\n\t  ELSE IF (LOG(u) < half*x**2 + d*(one - v + LOG(v))) THEN\n\t    fn_val = d*v\n\t    EXIT\n\t  END IF\n\tEND DO\n\n\tRETURN\n\tEND FUNCTION random_gamma1\n\n\n\n\t!FUNCTION random_gamma2(s, first) RESULT(fn_val)\n\tFUNCTION random_gamma2(s) RESULT(fn_val)\n\nc\t! Adapted from Fortran 77 code from the book:\nc\t!     Dagpunar, J. 'Principles of random variate generation'\nc\t!     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9\n\nc\t! FUNCTION GENERATES A RANDOM VARIATE IN [0,INFINITY) FROM\nc\t! A GAMMA DISTRIBUTION WITH DENSITY PROPORTIONAL TO\nc\t! GAMMA2**(S-1) * EXP(-GAMMA2),\nc\t! USING A SWITCHING METHOD.\n\nc\t!    S = SHAPE PARAMETER OF DISTRIBUTION\nc\t!          (REAL < 1.0)\n\n\tIMPLICIT NONE\n        REAL :: zero = 0.0, half = 0.5, one = 1.0, two = 2.0   \nc     *                          vsmall = TINY(1.0), vlarge = HUGE(1.0)\n        REAL:: vsmall=2E-34\n\nc        INTEGER, PARAMETER :: dp = SELECTED_REAL_KIND(12, 60)\n\n\t\nc        REAL, INTENT(IN)    :: s\n         REAL::s\n\nc\t!LOGICAL, INTENT(IN) :: first\n\tREAL                :: fn_val\n\nc\t!     Local variables\n\tREAL       :: r, x, w\nc        REAL, SAVE :: a, p, c, uf, vr, d\n        REAL :: a, p, c, uf, vr, d,rand\n      integer taux  \n\n\tIF (s <= zero .OR. s >= one) THEN\n\t  WRITE(*, *) 'SHAPE PARAMETER VALUE OUTSIDE PERMITTED RANGE'\n\t  STOP\n\tEND IF\n\nc\t!IF (first) THEN                        ! Initialization, if necessary\n\t  a = one - s\n\t  p = a/(a + s*EXP(-a))\n\t  IF (s < vsmall) THEN\n\t    WRITE(*, *) 'SHAPE PARAMETER VALUE TOO SMALL'\n\t    STOP\n\t  END IF\n\t  c = one/s\n\t  uf = p*(vsmall/a)**s\n\t  vr = one - vsmall\n\t  d = a*LOG(a)\nc\t!END IF\n\n\tDO\n\nc        CALL RANDOM_NUMBER(r)\nc        call system_clock(taux)       \nc        r=rand(taux)\n         r=rand(0)\n\t  \n        IF (r >= vr) THEN\n\t    CYCLE\n\t  ELSE IF (r > p) THEN\n\t    x = a - LOG((one - r)/(one - p))\n\t    w = a*LOG(x)-d\n\t  ELSE IF (r > uf) THEN\n\t    x = a*(r/p)**c\n\t    w = x\n\t  ELSE\n\t    fn_val = zero\n\t    RETURN\n\t  END IF\n\nc\t  CALL RANDOM_NUMBER(r)\nc         call system_clock(taux)\nc         r=rand(taux)\n          r=rand(0) \n\n\t  IF (one-r <= w .AND. r > zero) THEN\n\t    IF (r*(w + one) >= one) CYCLE\n\t    IF (-LOG(r) <= w) CYCLE\n\t  END IF\n\t  EXIT\n\tEND DO\n\n\tfn_val = x\n\tRETURN\n\n\tEND FUNCTION random_gamma2\n\n\n\n\n\tFUNCTION random_exponential() RESULT(fn_val)\n\nc\t! Adapted from Fortran 77 code from the book:\nc\t!     Dagpunar, J. 'Principles of random variate generation'\nc\t!     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9\n\nc\t! FUNCTION GENERATES A RANDOM VARIATE IN [0,INFINITY) FROM\nc\t! A NEGATIVE EXPONENTIAL DlSTRIBUTION WlTH DENSITY PROPORTIONAL\nc\t! TO EXP(-random_exponential), USING INVERSION.\n\n\t\n        REAL :: zero = 0.0, half = 0.5, one = 1.0, two = 2.0   \nc     *              vsmall = TINY(1.0), vlarge = HUGE(1.0)\n\tREAL  :: fn_val\n\nc\t!     Local variable\n\tREAL  :: r\n      integer taux       \n\n \tDO\n\nc        CALL RANDOM_NUMBER(r)\nc        call system_clock(taux)       \nc        r=rand(taux)\n         r=rand(0)\n\n\t  IF (r > zero) EXIT\n\tEND DO\n\n\tfn_val = -LOG(r)\n\tRETURN\n\n\tEND FUNCTION random_exponential\n\n\n",
    "created" : 1504102133734.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1064422815",
    "id" : "E69097A1",
    "lastKnownWriteTime" : 1132315679,
    "last_content_update" : 1132315679,
    "path" : "C:/Juan/CREAL/GitHub/survrec/src/bootstrap.f",
    "project_path" : "src/bootstrap.f",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "text"
}